// -*- c-file-style: "Stroustrup"; eval: (auto-complete-mode) -*-                                          

#include <string.h>

#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "i2c_manager.h"
#include "sh1106_def.h"
#include "font8x8_basic.h"

#define SDA_PIN GPIO_NUM_21
#define SCL_PIN GPIO_NUM_22

#define tag "SH1106"


void sh1106_set_display_start_line(i2c_cmd_handle_t cmd, uint_fast8_t start_line)
{
    // REQUIRES:
    //   0 <= start_line <= 63
    if (start_line <= 63)
    {
        i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_START_LINE | start_line, true);
    }
}

void sh1106_init()
{
    esp_err_t espRc;
    
    i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
    
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
    
    i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP_CTRL, true);
    i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP_ON, true);
    
    i2c_master_write_byte(cmd, OLED_CMD_SET_SEGMENT_REMAP_INVERSE, true); // reverse left-right mapping
    i2c_master_write_byte(cmd, OLED_CMD_SET_COM_SCAN_MODE_REVERSE, true); // reverse up-bottom mapping
    
    i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);
    
    i2c_master_write_byte(cmd, 0x00, true); // reset column low bits
    i2c_master_write_byte(cmd, 0x10, true); // reset column high bits
    i2c_master_write_byte(cmd, 0xB0, true); // reset page
    i2c_master_write_byte(cmd, 0x40, true); // set start line
    i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_OFFSET, true);
    i2c_master_write_byte(cmd, 0x00, true);
    
    i2c_master_stop(cmd);
    
    espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
    if (espRc == ESP_OK)
    {
        ESP_LOGI(tag, "OLED configured successfully");
    }
    else
    {
        ESP_LOGE(tag, "OLED configuration failed. code: 0x%.2X", espRc);
    }
    i2c_manager::instance()->ReleaseCmdHandle(cmd);
}

void task_sh1106_display_pattern(void *ignore)
{
    for (uint8_t i = 0; i < 8; i++)
    {
        i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
        i2c_master_write_byte(cmd, 0xB0 | i, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
        for (uint8_t j = 0; j < 132; j++)
        {
            i2c_master_write_byte(cmd, 0xFF >> (j % 8), true);
        }
        i2c_master_stop(cmd);
        i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
        i2c_manager::instance()->ReleaseCmdHandle(cmd);
    }
}

void task_sh1106_display_clear(void *ignore)
{
    uint8_t zero[132];
    memset(zero, 0, 132);
    for (uint8_t i = 0; i < 8; i++)
    {
        i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
        i2c_master_write_byte(cmd, 0xB0 | i, true);
        
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
        i2c_master_write(cmd, zero, 132, true);
        i2c_master_stop(cmd);
        i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
        i2c_manager::instance()->ReleaseCmdHandle(cmd);
    }

    i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
    i2c_master_write_byte(cmd, 0x00, true); // reset column
    i2c_master_write_byte(cmd, 0x10, true);
    i2c_master_write_byte(cmd, 0xB0, true); // reset page
    i2c_master_stop(cmd);
    i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
    i2c_manager::instance()->ReleaseCmdHandle(cmd);
}


void task_sh1106_contrast(void *ignore)
{
    i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
    
    uint8_t contrast = 0;
    uint8_t direction = 1;
    while (true)
    {
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
        i2c_master_write_byte(cmd, OLED_CMD_SET_CONTRAST, true);
        i2c_master_write_byte(cmd, contrast, true);
        i2c_master_stop(cmd);
        i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
        i2c_cmd_link_delete(cmd);
        vTaskDelay(1/portTICK_PERIOD_MS);
        
        contrast += direction;
        if (contrast == 0xFF) { direction = -1; }
        if (contrast == 0x0) { direction = 1; }
    }
    vTaskDelete(NULL);
}

void sh1106_print_line(int row, const char *text)
{
    uint8_t text_len = strlen(text);
    char line[18];
    strncpy(line, text, 16);
    while (strlen(line) < 16)
        strcat(line, " ");
    
    i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
    
    uint8_t cur_page = row;

    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
    
    i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
    i2c_master_write_byte(cmd, 0x04, true); // reset column
    i2c_master_write_byte(cmd, 0x10, true);
    i2c_master_write_byte(cmd, 0xB0 | cur_page, true); // reset page
    
    i2c_master_stop(cmd);
    i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
    i2c_manager::instance()->ReleaseCmdHandle(cmd);
    
    for (uint8_t i = 0; i < 16; i++)
    {
        cmd = i2c_manager::instance()->GetCmdHandle();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
        
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
        i2c_master_write(cmd, font8x8_basic_tr[(uint8_t)line[i]], 8, true);
        
        i2c_master_stop(cmd);
        i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
        i2c_manager::instance()->ReleaseCmdHandle(cmd);
    }
}

//----------------------------------------------------------------------------------------------------------
void task_sh1106_display_text(const void *arg_text)
{
    char *text = (char*)arg_text;
    uint8_t text_len = strlen(text);

    i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
    
    uint8_t cur_page = 0;    

    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
    
    i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
    i2c_master_write_byte(cmd, 0x04, true); // reset column
    i2c_master_write_byte(cmd, 0x10, true);
    i2c_master_write_byte(cmd, 0xB0 | cur_page, true); // reset page
    
    i2c_master_stop(cmd);
    i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
    i2c_manager::instance()->ReleaseCmdHandle(cmd);
    
    for (uint8_t i = 0; i < text_len; i++)
    {
        if (text[i] == '\n')
        {
            cmd = i2c_manager::instance()->GetCmdHandle();
            i2c_master_start(cmd);
            i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
            
            i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
            i2c_master_write_byte(cmd, 0x04, true); // reset column
            i2c_master_write_byte(cmd, 0x10, true);
            i2c_master_write_byte(cmd, 0xB0 | ++cur_page, true); // increment page
            
            i2c_master_stop(cmd);
            i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
            i2c_manager::instance()->ReleaseCmdHandle(cmd);
        }
        else
        {
            cmd = i2c_manager::instance()->GetCmdHandle();
            i2c_master_start(cmd);
            i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
            
            i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
            i2c_master_write(cmd, font8x8_basic_tr[(uint8_t)text[i]], 8, true);
            
            i2c_master_stop(cmd);
            i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
            i2c_manager::instance()->ReleaseCmdHandle(cmd);
        }
    }
}


//--------------------------------------------------------------------------------
typedef uint8_t frame_buffer_t[132][8];


void task_sh1106_write_fb(frame_buffer_t *fb)
{
    for (uint8_t i = 0; i < 8; i++)
    {
        i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
        i2c_master_write_byte(cmd, 0xB0 | i, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
        for (uint8_t j = 0; j < 132; j++)
        {
            i2c_master_write_byte(cmd, *fb[j][i], true);
        }
        i2c_master_stop(cmd);
        i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
        i2c_manager::instance()->ReleaseCmdHandle(cmd);
    }
}


//--------------------------------------------------------------------------------
void write_fb(frame_buffer_t *fb)
{
}
//--------------------------------------------------------------------------------
void clear_fb(frame_buffer_t *fb)
{
    memset(fb, 0, 8*132);
}
//--------------------------------------------------------------------------------
void sh1106_set_pixel(frame_buffer_t *fb, uint8_t x, uint8_t y, bool p)
{
    if((x > 127) || (y > 63))
    {
        ESP_LOGE(tag, "sh1106_set_pixel x/y out of range.");
        return;
    }
    uint8_t page;
    uint8_t column;
    uint8_t bit;

    page = y / 8;
    column = x+4;
    bit = y % 8;

    uint8_t v = *fb[column][page];
    if (p)
        v |= 1>>bit;
    else
        v &= ~(1>>bit);
    *fb[column][page] = v;
}


