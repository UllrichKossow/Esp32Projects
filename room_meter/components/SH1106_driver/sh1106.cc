// -*- c-file-style: "Stroustrup"; eval: (auto-complete-mode) -*-                                          

#include "sh1106.h"
#include <string.h>

#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"

#include "sdkconfig.h" // generated by "make menuconfig"

#include "i2c_manager.h"
#include "sh1106_def.h"
#include "font8x8_basic.h"


static const char *tag = "SH1106";


void sh1106_set_display_start_line(i2c_cmd_handle_t cmd, uint_fast8_t start_line)
{
    // REQUIRES:
    //   0 <= start_line <= 63
    if (start_line <= 63)
    {
        i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_START_LINE | start_line, true);
    }
}


void sh1106_init()
{
    esp_err_t espRc;
    
    i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
    
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
    
    i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP_CTRL, true);
    i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP_ON, true);
    
    i2c_master_write_byte(cmd, OLED_CMD_SET_SEGMENT_REMAP_INVERSE, true); // reverse left-right mapping
    i2c_master_write_byte(cmd, OLED_CMD_SET_COM_SCAN_MODE_REVERSE, true); // reverse up-bottom mapping

    i2c_master_write_byte(cmd, OLED_CMD_SET_CONTRAST, true);
    i2c_master_write_byte(cmd, 0x10, true);

    i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);
    
    i2c_master_write_byte(cmd, 0x00, true); // reset column low bits
    i2c_master_write_byte(cmd, 0x10, true); // reset column high bits
    i2c_master_write_byte(cmd, 0xB0, true); // reset page
    i2c_master_write_byte(cmd, 0x40, true); // set start line
    i2c_master_write_byte(cmd, OLED_CMD_SET_DISPLAY_OFFSET, true);
    i2c_master_write_byte(cmd, 0x00, true);
    
    i2c_master_stop(cmd);
    
    espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
    if (espRc == ESP_OK)
    {
        ESP_LOGI(tag, "OLED configured successfully");
    }
    else
    {
        ESP_LOGE(tag, "OLED configuration failed. code: 0x%.2X", espRc);
    }
    i2c_manager::instance()->ReleaseCmdHandle(cmd);
}


void task_sh1106_display_pattern(void *ignore)
{
    for (uint8_t i = 0; i < 8; i++)
    {
        i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
        i2c_master_write_byte(cmd, 0xB0 | i, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
        for (uint8_t j = 0; j < 132; j++)
        {
            i2c_master_write_byte(cmd, 0xFF >> (j % 8), true);
        }
        i2c_master_stop(cmd);
        i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
        i2c_manager::instance()->ReleaseCmdHandle(cmd);
    }
}


void sh1106_display_clear()
{
    uint8_t zero[132];
    memset(zero, 0, 132);
    for (uint8_t i = 0; i < 8; i++)
    {
        i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
        i2c_master_write_byte(cmd, 0xB0 | i, true);
        
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
        i2c_master_write(cmd, zero, 132, true);
        i2c_master_stop(cmd);
        i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
        i2c_manager::instance()->ReleaseCmdHandle(cmd);
    }

    i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
    i2c_master_write_byte(cmd, 0x00, true); // reset column
    i2c_master_write_byte(cmd, 0x10, true);
    i2c_master_write_byte(cmd, 0xB0, true); // reset page
    i2c_master_stop(cmd);
    i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
    i2c_manager::instance()->ReleaseCmdHandle(cmd);
}


void sh1106_print_line(int row, const char *text)
{
    uint8_t text_len = strlen(text);
    char line[18];
    strncpy(line, text, 16);
    while (strlen(line) < 16)
        strcat(line, " ");
    
    i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
    
    uint8_t cur_page = row;

    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
    
    i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
    i2c_master_write_byte(cmd, 0x04, true); // reset column
    i2c_master_write_byte(cmd, 0x10, true);
    i2c_master_write_byte(cmd, 0xB0 | cur_page, true); // reset page
    
    i2c_master_stop(cmd);
    i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
    i2c_manager::instance()->ReleaseCmdHandle(cmd);
    
    for (uint8_t i = 0; i < 16; i++)
    {
        cmd = i2c_manager::instance()->GetCmdHandle();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
        
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
        i2c_master_write(cmd, font8x8_basic_tr[(uint8_t)line[i]], 8, true);
        
        i2c_master_stop(cmd);
        i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
        i2c_manager::instance()->ReleaseCmdHandle(cmd);
    }
}


//--------------------------------------------------------------------------------

void sh1106_write_fb(frame_buffer_t *fb)
{
    for (uint8_t i = 0; i < 8; i++)
    {
        i2c_cmd_handle_t cmd = i2c_manager::instance()->GetCmdHandle();
        i2c_master_start(cmd);
        i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
        i2c_master_write_byte(cmd, 0xB0 | i, true);
        i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
        for (uint8_t j = 0; j < 132; j++)
        {           
            i2c_master_write_byte(cmd, (*fb)[j][i], true);
        }
        i2c_master_stop(cmd);
        i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
        i2c_manager::instance()->ReleaseCmdHandle(cmd);
    }
}


//--------------------------------------------------------------------------------
void sh1106_clear_fb(frame_buffer_t *fb)
{
    memset(fb, 0, 8*132);
}


//--------------------------------------------------------------------------------
void sh1106_set_pixel(frame_buffer_t *fb, uint8_t x, uint8_t y, bool p)
{
    if((x > 127) || (y > 63))
    {
        ESP_LOGE(tag, "sh1106_set_pixel x/y out of range.");
        return;
    }
    uint8_t page;
    uint8_t column;
    uint8_t bit;

    page = y / 8;
    column = x+4;
    bit = y % 8;
	//ESP_LOGI(tag, "page=%i column=%i bit=%i", page, column, bit);
	
    uint8_t v = (*fb)[column][page];
    if (p)
        v |= 1<<bit;
    else
        v &= ~(1<<bit);
        
    (*fb)[column][page] = v;
}

//--------------------------------------------------------------------------------
void play_graph()
{
    sh1106_display_clear();
    vTaskDelay(1000/portTICK_PERIOD_MS);
    frame_buffer_t fb;
    sh1106_clear_fb(&fb);
    for (int i = 0; i < 64; ++i)
    {
	    sh1106_set_pixel(&fb, i, i, true);
    }
    sh1106_write_fb(&fb);
    vTaskDelay(5000/portTICK_PERIOD_MS);
    sh1106_display_clear();
}


//--------------------------------------------------------------------------------
void sh1106_line(frame_buffer_t *fb, int x0, int y0, int x1, int y1)
{
    int dx = abs(x1 - x0);
    int sx = x0 < x1 ? 1 : -1;
    int dy = -abs(y1 - y0);
    int sy = y0 < y1 ? 1 : -1;
    int err = dx + dy;
    int  e2; /* error value e_xy */

    while (true)
    {
        sh1106_set_pixel(fb, x0, y0, true);
        if (x0 == x1 && y0 == y1)
            break;
        e2 = 2*err;
        if (e2 > dy)
        {
            err += dy;
            x0 += sx;
        } /* e_xy+e_x > 0 */
        if (e2 < dx)
        {
            err += dx;
            y0 += sy;
        } /* e_xy+e_y < 0 */
    }
}
